
'use server';

import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import type { BlogPost } from './types';
import { adminAuth } from './firebase/admin-config';
import { auth } from './firebase/config';

const BlogPostActionSchema = z.object({
  title: z.string(),
  introduction: z.string(),
  featuredImageUrl: z.string().optional(),
  featuredImageHint: z.string(),
  sections: z.array(
    z.object({
      heading: z.string(),
      content: z.string(),
      imageUrl: z.string().optional(),
      imageHint: z.string().optional(),
    })
  ),
  conclusion: z.string(),
  suggestedTags: z.array(z.string()),
  category: z.string(),
  status: z.enum(['Published', 'Draft', 'In Review', 'Archived']),
  slug: z.string().optional(), // Slug is now generated by the backend use case
  generationCost: z.number().optional(),
});

type BlogPostInput = z.infer<typeof BlogPostActionSchema>;

/**
 * Creates a new blog post by calling the secure API route.
 * This is a server action called from the client.
 */
export async function createBlogPostAction(input: Omit<BlogPostInput, 'slug'>, idToken: string) {
  try {
    if (!idToken) {
        throw new Error('El token de autenticaci贸n es obligatorio.');
    }

    // Slug is now generated server-side in the use case.
    // We just pass the validated client-side data.
    const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
    const response = await fetch(`${appUrl}/api/blog`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${idToken}`,
        },
        body: JSON.stringify(input),
        cache: 'no-store', // Disable caching for this API call
    });

    const result = await response.json();

    if (!response.ok) {
        throw new Error(result.error?.message || `Error en el servidor: ${response.status}`);
    }
    
    revalidatePath('/dashboard/admin/blog');
    revalidatePath('/blog');

    return { success: true, post: result };
  } catch (error) {
    console.error('Error detallado en la acci贸n del blog:', error);
    
    let errorMessage = 'Un error desconocido ocurri贸.';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return {
      success: false,
      error: `No se pudo crear la entrada de blog: ${errorMessage}`,
    };
  }
}

// Helper to get token for client-side actions that need it
const getAuthToken = async (): Promise<string> => {
    const currentUser = auth.currentUser;
    if (!currentUser) throw new Error("User not authenticated.");
    return currentUser.getIdToken();
};

export async function getBlogPostsAction(): Promise<{ posts?: BlogPost[], error?: string }> {
    try {
        const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
        const response = await fetch(`${appUrl}/api/blog`, { cache: 'no-store', next: { tags: ['posts'] }});
        if (!response.ok) throw new Error("Failed to fetch posts.");
        const posts = await response.json();
        return { posts };
    } catch (error) {
        console.error('Error fetching all blog posts:', error);
        return { error: 'No se pudieron obtener las entradas del blog.' };
    }
}

export async function getPublishedBlogPosts(): Promise<{ posts: BlogPost[], error?: string }> {
    try {
        const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
        // This could be a separate endpoint GET /api/blog?status=published
        // For now, we fetch all and filter client-side for simplicity, but a dedicated endpoint is better.
        const response = await fetch(`${appUrl}/api/blog`, { cache: 'no-store', next: { tags: ['posts'] }});
        if (!response.ok) throw new Error("Failed to fetch posts.");
        const allPosts = await response.json();
        const publishedPosts = allPosts.filter((p: BlogPost) => p.status === 'Published');
        return { posts: publishedPosts };
    } catch (error) {
        console.error('Error fetching published blog posts:', error);
        return { posts: [] };
    }
}


export async function getBlogPostBySlug(slug: string): Promise<{ post: BlogPost | null, error?: string }> {
     try {
        const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
        // We'll need a new endpoint for this: GET /api/blog/slug/[slug]
        // For now, fetching all and filtering is a temporary workaround.
        const response = await fetch(`${appUrl}/api/blog`, { cache: 'no-store', next: { tags: ['posts', `post-slug-${slug}`] }});
         if (!response.ok) throw new Error("Failed to fetch posts.");
        const allPosts = await response.json();
        const post = allPosts.find((p: BlogPost) => p.slug === slug);
        return { post: post || null };
    } catch (error) {
        console.error('Error fetching post by slug:', error);
        return { post: null };
    }
}


export async function getBlogPostByIdAction(id: string) {
    try {
        const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
        const response = await fetch(`${appUrl}/api/blog/${id}`, { cache: 'no-store', next: { tags: [`post-${id}`] }});
        if (!response.ok) {
            if (response.status === 404) return { error: 'No se encontr贸 la entrada.' };
            throw new Error("Failed to fetch post.");
        }
        const post = await response.json();
        return { post };
    } catch (error) {
        console.error('Error fetching post by ID:', error);
        return { error: 'No se pudo obtener la entrada.' };
    }
}


export async function updateBlogPostAction(id: string, data: Partial<BlogPost>) {
    try {
        const idToken = await getAuthToken();
        const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
        const response = await fetch(`${appUrl}/api/blog/${id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${idToken}` },
            body: JSON.stringify(data),
            cache: 'no-store',
        });
        if (!response.ok) {
            const result = await response.json();
            throw new Error(result.error?.message || 'Failed to update post.');
        }

        revalidatePath('/dashboard/admin/blog');
        revalidatePath(`/blog/${data.slug}`);
        revalidatePath(`/blog/preview/${id}`);
        return { success: true };
    } catch (error) {
        console.error('Error updating post:', error);
        const message = error instanceof Error ? error.message : 'No se pudo actualizar la entrada.';
        return { error: message };
    }
}


export async function updateBlogPostStatusAction(id: string, status: 'Published' | 'Draft' | 'In Review' | 'Archived') {
    return updateBlogPostAction(id, { status });
}

export async function deleteBlogPostAction(id: string) {
    try {
        const idToken = await getAuthToken();
        const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:9002';
        const response = await fetch(`${appUrl}/api/blog/${id}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${idToken}` },
            cache: 'no-store',
        });

        if (!response.ok) {
            const result = await response.json();
            throw new Error(result.error?.message || 'Failed to delete post.');
        }

        revalidatePath('/dashboard/admin/blog');
        revalidatePath('/blog');
        return { success: true };
    } catch (error) {
        console.error('Error deleting post:', error);
        const message = error instanceof Error ? error.message : 'No se pudo eliminar la entrada.';
        return { error: message };
    }
}
